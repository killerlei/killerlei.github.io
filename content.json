[{"title":"vue开发跨域解决办法","date":"2017-10-15T14:58:20.000Z","path":"2017/10/15/vue开发跨域解决办法/","text":"跨域是前端开发绕不开的一个话题,尤其在前后端分离的大趋势下,更加变得家常便饭,比如vue本地开发,调用接口,就要跨域. 前面几篇文章,也有所设计跨域相关指示,这里总结一下,前端使用vue开发解决跨域的问题. 1.因为跨域是浏览器的安全策略,在chorme浏览器中,可以在快捷图标中设置 –disable-web-security,非常方便.但是在最新chorme中还要稍加复杂的设置.2.使用chorme插件Allow-Control-Allow-Origin,需要翻墙,实际用起来,效果还不错.偶尔失效. 3.使用jsonp ,前面有文章jsonp使用及promise封装. 4.使用node代理,如使用代理解决跨域限制 5.使用vue-cli中配置的插件webpack-dev-middleware,实现代理.这要是本文要写的.原理同4,都是使用nodejs做个代理,只是过程不同. dev.server.js var devMiddleware = require(&apos;webpack-dev-middleware&apos;)(compiler, { publicPath: webpackConfig.output.publicPath, stats: { colors: true, chunks: false } }) // proxy api requests Object.keys(proxyTable).forEach(function (context) { var options = proxyTable[context] if (typeof options === &apos;string&apos;) { options = { target: options } } app.use(proxyMiddleware(context, options)) }) config/index.js dev: { env: require(&apos;./dev.env&apos;), port: 8081, assetsSubDirectory: &apos;static&apos;, assetsPublicPath: &apos;/&apos;, /*assetsSubDirectory: &apos;/xxxxx&apos;, assetsPublicPath: &apos;&apos;,*/ proxyTable: proxyConfig.proxyList, cssSourceMap: false } config/proxyConfig.js module.exports = { proxyList: { &apos;/apiDev&apos;: { //真实跨域接口 target: &apos;http://xxxxx.com&apos;, changeOrigin: true, pathRewrite: { &apos;^/apiDev&apos;: &apos;&apos; } } } } 在开发中使用接口如 /apiDev/getAll,会被代理到http://xxxxx.com/getAll. 开发完成后,要上测试或者生产,在换成http://xxxxx.com/getAll. 这部分也可以通过配置实现自动切换,以后会写到.","tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"},{"name":"代理","slug":"代理","permalink":"http://yoursite.com/tags/代理/"}]},{"title":"vue-cli中process.env.NODE_ENV","date":"2017-10-08T17:25:32.000Z","path":"2017/10/08/vue-cli中process-env-NODE-ENV/","text":"看前面vue-cli讲解的文章,对process.env.NODE_ENV,一直不理解是怎么设置的,怎么就变成production或者development // webpack.base.config.js output: { path: config.build.assetsRoot, filename: &apos;[name].js&apos;, publicPath: process.env.NODE_ENV === &apos;production&apos; ? config.build.assetsPublicPath : config.dev.assetsPublicPath }, 通过看了不同的文章,大概有所了解. 请参考process.env 改变运行脚本的环境变量 业务代码如何判断生产/开发环境 DefinePlugin中的淫技巧 process.envprocess对象用于处理与当前进程相关的事情，它是一个全局对象，可以在任何地方直接访问到它而无需引入额外模块。 它是 EventEmitter 的一个实例。 process.env 获取当前系统环境信息的对象，常规可以用来进一步获取环境变量、用户名等系统信息： console.log(process.env); console.log(&apos;username: &apos; + process.env.USERNAME); console.log(&apos;PATH: &apos; + process.env.PATH); webpack 开发和生产的区别开发环境(development)和生产环境(production)的构建目标差异很大。 在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。 而在生产环境中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。 由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置。 分别为 webpack.config.js webpack.dev.js webpack.production.js 如何区分生产环境还是开发环境引入process.env，这样就可以在业务代码中靠process.env.NODE_ENV来判断. 在webpack.base.config.js区分process.env.NODE_ENV来决定设置webpack配置为开发还是生产. // webpack.base.config.js output: { path: config.build.assetsRoot, filename: &apos;[name].js&apos;, publicPath: process.env.NODE_ENV === &apos;production&apos; ? config.build.assetsPublicPath : config.dev.assetsPublicPath }, process.env.NODE_ENV如何设置 因为process是nodejs全局变量,可以通过命令行设置 export NODE_ENV = production &amp;&amp; webpack export NODE_ENV = dev &amp;&amp; webpack 也可以通过package.json设置 { &quot;scripts&quot;: { &quot;dev&quot;: &quot;export NODE_ENV=dev&amp;&amp;webpack --progress --colors&quot;, &quot;production&quot;: &quot;export NODE_ENV=production&amp;&amp;webpack --progress --colors&quot;, }, 也可以借助webpack.DefinePlugin插件,在代码里面设置,如 //webpack.dev.js plugins: [ new webpack.DefinePlugin({ &apos;process.env&apos;: config.dev.env }), //config/index.js dev: { env: require(&apos;./dev.env&apos;), port: 8080, //config/dev.env.js var merge = require(&apos;webpack-merge&apos;) var prodEnv = require(&apos;./prod.env&apos;) module.exports = merge(prodEnv, { NODE_ENV: &apos;&quot;development&quot;&apos; }) 但是在build.js中 process.env.NODE_ENV = ‘production’ ,不知道这个和webpack.prod.js里面的有什么区别.","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"vue-cli","slug":"vue-cli","permalink":"http://yoursite.com/tags/vue-cli/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"vue-cli编译打包后起node服务测试","date":"2017-10-08T14:37:32.000Z","path":"2017/10/08/vue-cli编译打包后起node服务测试/","text":"使用vue-cli开发项目中,一直使用dev-server.js这个本地服务,实现从内存中读取文件. 项目完成后,要编译打包生成打包文件,提示不能通过打开file//方式访问,需要另外起服务访问. 但是打包好后,不可能立即放到真实服务器中,还需要通过在本地测试一下,故另开一个node服务. 原因因为打包后生成的文件如script/link等路径都是绝对路径,当然找不到了. 解决1 修改配置如果弄明白vue-cli中webpack的配置,下面这个肯定明白,就是把绝对路径形式改成相对路径,但是不知道对放到真实服务器上有没影响. 这里有一个万能解决办法： 1. 将config/index.js 里面的 assetsPublicPath:&apos;/&apos; 改为assetsPublicPath:&apos;./&apos; 2. build/util.js里面的 if (options.extract) { return ExtractTextPlugin.extract({ use: loaders, fallback: &apos;vue-style-loader&apos;, publicPath:&apos;/&apos; }) 将其中的publicPath改为：publicPath：&apos;../../&apos;就可以了。这样打包出来的路径就是正确的了。 第一个是为了改变js中引入图片的路径，改为./ 就是指在当前路径，这个.代表的路径就是assetsRoot+assetsSubDictionary，我这里定位到dist/static/ ，加上图片前缀img，就可以找到了。 第二种是为了改变vue文件中使用style样式里面例如background:url(&apos;xxx&apos;)，这样的路径，因为style最终变成css文件在dist/static/css里面，我们的图片放在dist/static/img中，那么加上../../变成dist目录下，默认的目录前缀是static，img是图片默认前缀，这样就可以定位到图片。 解决2 起一个node服务,并定位静态资源入口1.新建build/prod-server.js var express = require(&apos;express&apos;) var app = express() var opn = require(&apos;opn&apos;) var path = require(&apos;path&apos;) var distPath = path.join(__dirname,&quot;../dist&quot;); //静态资源目录入口 app.use(express.static(distPath)); module.exports = app.listen(8081, function (err) { if (err) { console.log(err) return } var uri = &apos;http://localhost:&apos; + 8081+&quot;/&quot; console.log(&apos;Listening at &apos; + uri + &apos;\\n&apos;) opn(uri) }) 直接在项目目录命令行运行 node prod-server.js 就可以访问了 2 也可以在package.json中设置 &quot;scripts&quot;: { &quot;dev&quot;: &quot;node build/dev-server.js&quot;, &quot;build&quot;: &quot;node build/build.js&quot;, &quot;local-server&quot;: &quot;node build/prod-server.js&quot; }, 这样也可以直接 npm run local-server","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"vue-cli","slug":"vue-cli","permalink":"http://yoursite.com/tags/vue-cli/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"vue-cli-2中webpack的配置分析二","date":"2017-10-08T10:44:20.000Z","path":"2017/10/08/vue-cli-2中webpack的配置分析二/","text":"这片也是转载,叶家伟的博客,这里有一系列的vue-cli中webpack分析文章,可以移步阅读.另外还找到另外一片博客vue-cli的webpack模板项目配置文件分析加上前面滴滴那篇介绍,对比读起来肯定会理解的快.总之,网上有已有大量的学习资料,前人栽树,后人乘凉,感谢. config/index.js// see http://vuejs-templates.github.io/webpack for documentation. // path是node.js的路径模块，用来处理路径统一的问题 var path = require(&apos;path&apos;) module.exports = { // 下面是build也就是生产编译环境下的一些配置 build: { // 导入prod.env.js配置文件，只要用来指定当前环境，详细见(1) env: require(&apos;./prod.env&apos;), // 下面是相对路径的拼接，假如当前跟目录是config，那么下面配置的index属性的属性值就是dist/index.html index: path.resolve(__dirname, &apos;../dist/index.html&apos;), // 下面定义的是静态资源的根目录 也就是dist目录 assetsRoot: path.resolve(__dirname, &apos;../dist&apos;), // 下面定义的是静态资源根目录的子目录static，也就是dist目录下面的static assetsSubDirectory: &apos;static&apos;, // 下面定义的是静态资源的公开路径，也就是真正的引用路径 assetsPublicPath: &apos;/&apos;, // 下面定义是否生成生产环境的sourcmap，sourcmap是用来debug编译后文件的，通过映射到编译前文件来实现 productionSourceMap: true, // Gzip off by default as many popular static hosts such as // Surge or Netlify already gzip all static assets for you. // Before setting to `true`, make sure to: // npm install --save-dev compression-webpack-plugin // 下面是是否在生产环境中压缩代码，如果要压缩必须安装compression-webpack-plugin productionGzip: false, // 下面定义要压缩哪些类型的文件 productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;], // Run the build command with an extra argument to // View the bundle analyzer report after build finishes: // `npm run build --report` // Set to `true` or `false` to always turn it on or off // 下面是用来开启编译完成后的报告，可以通过设置值为true和false来开启或关闭 // 下面的process.env.npm_config_report表示定义的一个npm_config_report环境变量，可以自行设置 bundleAnalyzerReport: process.env.npm_config_report }, dev: { // 引入当前目录下的dev.env.js，用来指明开发环境，详见(2) env: require(&apos;./dev.env&apos;), // 下面是dev-server的端口号，可以自行更改 port: 8080, // 下面表示是否自定代开浏览器 autoOpenBrowser: true, assetsSubDirectory: &apos;static&apos;, assetsPublicPath: &apos;/&apos;, // 下面是代理表，作用是用来，建一个虚拟api服务器用来代理本机的请求，只能用于开发模式 // 详见(3) proxyTable: {}, // CSS Sourcemaps off by default because relative paths are &quot;buggy&quot; // with this option, according to the CSS-Loader README // (https://github.com/webpack/css-loader#sourcemaps) // In our experience, they generally work as expected, // just be aware of this issue when enabling this option. // 是否生成css，map文件，上面这段英文就是说使用这个cssmap可能存在问题，但是按照经验，问题不大，可以使用 // 给人觉得没必要用这个，css出了问题，直接控制台不就完事了 cssSourceMap: false } } prod.env.jsmodule.exports = { // 作用很明显，就是导出一个对象，NODE_ENV是一个环境变量，指定production环境 NODE_ENV: &apos;&quot;production&quot;&apos; } dev.env.js// 首先引入的是webpack的merge插件，该插件是用来合并对象，也就是配置文件用的，相同的选项会被覆盖，至于这里为什么多次一举，可能另有他图吧 var merge = require(&apos;webpack-merge&apos;) // 导入prod.env.js配置文件 var prodEnv = require(&apos;./prod.env&apos;) // 将两个配置对象合并，最终结果是 NODE_ENV: &apos;&quot;development&quot;&apos; module.exports = merge(prodEnv, { NODE_ENV: &apos;&quot;development&quot;&apos; }) proxyTable用法vue-cli使用这个功能是借助http-proxy-middleware插件，一般解决跨域请求api proxyTable: { &apos;/list&apos;: { target: &apos;http://api.xxxxxxxx.com&apos;, -&gt; 目标url地址 changeOrigin: true, -&gt; 指示是否跨域 pathRewrite: { &apos;^/list&apos;: &apos;/list&apos; -&gt; 可以使用 /list 等价于 api.xxxxxxxx.com/list } } }","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"vue-cli","slug":"vue-cli","permalink":"http://yoursite.com/tags/vue-cli/"}]},{"title":"vue-cli(#2)中webpack的配置(一)","date":"2017-10-07T22:39:39.000Z","path":"2017/10/07/vue-cli-2-中webpack的配置-一/","text":"这篇基本上转载自滴滴前端团队的一片文章,感谢这样优秀的前端团队. 目录结构. ├── README.md ├── build │ ├── build.js │ ├── check-versions.js │ ├── dev-client.js │ ├── dev-server.js │ ├── utils.js │ ├── webpack.base.conf.js │ ├── webpack.dev.conf.js │ └── webpack.prod.conf.js ├── config │ ├── dev.env.js │ ├── index.js │ └── prod.env.js ├── index.html ├── package.json ├── src │ ├── App.vue │ ├── assets │ │ └── logo.png │ ├── components │ │ └── Hello.vue │ └── main.js └── static package.json我们可以看到 &quot;scripts&quot;: { &quot;dev&quot;: &quot;node build/dev-server.js&quot;, &quot;build&quot;: &quot;node build/build.js&quot;, &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot; } 当我们执行 npm run dev / npm run build 时运行的是 node build/dev-server.js 或 node build/build.js dev-server.js// 检查 Node 和 npm 版本 require(&apos;./check-versions&apos;)() // 获取 config/index.js 的默认配置 var config = require(&apos;../config&apos;) // 如果 Node 的环境无法判断当前是 dev / product 环境 // 使用 config.dev.env.NODE_ENV 作为当前的环境 if (!process.env.NODE_ENV) process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV) // 使用 NodeJS 自带的文件路径工具 var path = require(&apos;path&apos;) // 使用 express var express = require(&apos;express&apos;) // 使用 webpack var webpack = require(&apos;webpack&apos;) // 一个可以强制打开浏览器并跳转到指定 url 的插件 var opn = require(&apos;opn&apos;) // 使用 proxyTable var proxyMiddleware = require(&apos;http-proxy-middleware&apos;) // 使用 dev 环境的 webpack 配置 var webpackConfig = require(&apos;./webpack.dev.conf&apos;) // default port where dev server listens for incoming traffic // 如果没有指定运行端口，使用 config.dev.port 作为运行端口 var port = process.env.PORT || config.dev.port // Define HTTP proxies to your custom API backend // https://github.com/chimurai/http-proxy-middleware // 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置 var proxyTable = config.dev.proxyTable // 使用 express 启动一个服务 var app = express() // 启动 webpack 进行编译 var compiler = webpack(webpackConfig) // 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中 var devMiddleware = require(&apos;webpack-dev-middleware&apos;)(compiler, { publicPath: webpackConfig.output.publicPath, stats: { colors: true, chunks: false } }) // 启动 webpack-hot-middleware，也就是我们常说的 Hot-reload var hotMiddleware = require(&apos;webpack-hot-middleware&apos;)(compiler) // force page reload when html-webpack-plugin template changes compiler.plugin(&apos;compilation&apos;, function (compilation) { compilation.plugin(&apos;html-webpack-plugin-after-emit&apos;, function (data, cb) { hotMiddleware.publish({ action: &apos;reload&apos; }) cb() }) }) // proxy api requests // 将 proxyTable 中的请求配置挂在到启动的 express 服务上 Object.keys(proxyTable).forEach(function (context) { var options = proxyTable[context] if (typeof options === &apos;string&apos;) { options = { target: options } } app.use(proxyMiddleware(context, options)) }) // handle fallback for HTML5 history API // 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址 app.use(require(&apos;connect-history-api-fallback&apos;)()) // serve webpack bundle output // 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上 app.use(devMiddleware) // enable hot-reload and state-preserving // compilation error display // 将 Hot-reload 挂在到 express 服务上 app.use(hotMiddleware) // serve pure static assets // 拼接 static 文件夹的静态资源路径 var staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory) // 为静态资源提供响应服务 app.use(staticPath, express.static(&apos;./static&apos;)) // 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露 module.exports = app.listen(port, function (err) { if (err) { console.log(err) return } var uri = &apos;http://localhost:&apos; + port console.log(&apos;Listening at &apos; + uri + &apos;\\n&apos;) // when env is testing, don&apos;t need open it // 如果不是测试环境，自动打开浏览器并跳到我们的开发地址 if (process.env.NODE_ENV !== &apos;testing&apos;) { opn(uri) } }) webpack.dev.conf.js// 同样的使用了 config/index.js var config = require(&apos;../config&apos;) // 使用 webpack var webpack = require(&apos;webpack&apos;) // 使用 webpack 配置合并插件 var merge = require(&apos;webpack-merge&apos;) // 使用一些小工具 var utils = require(&apos;./utils&apos;) // 加载 webpack.base.conf var baseWebpackConfig = require(&apos;./webpack.base.conf&apos;) // 使用 html-webpack-plugin 插件，这个插件可以帮我们自动生成 html 并且注入到 .html 文件中 var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) // add hot-reload related code to entry chunks // 将 Hol-reload 相对路径添加到 webpack.base.conf 的 对应 entry 前 Object.keys(baseWebpackConfig.entry).forEach(function (name) { baseWebpackConfig.entry[name] = [&apos;./build/dev-client&apos;].concat(baseWebpackConfig.entry[name]) }) // 将我们 webpack.dev.conf.js 的配置和 webpack.base.conf.js 的配置合并 module.exports = merge(baseWebpackConfig, { module: { // 使用 styleLoaders loaders: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap }) }, // eval-source-map is faster for development // 使用 #eval-source-map 模式作为开发工具，此配置可参考 DDFE 往期文章详细了解 devtool: &apos;#eval-source-map&apos;, plugins: [ // definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串 new webpack.DefinePlugin({ &apos;process.env&apos;: config.dev.env }), // https://github.com/glenjamin/webpack-hot-middleware#installation--usage new webpack.optimize.OccurenceOrderPlugin(), // HotModule 插件在页面进行变更的时候只会重回对应的页面模块，不会重绘整个 html 文件 new webpack.HotModuleReplacementPlugin(), // 使用了 NoErrorsPlugin 后页面中的报错不会阻塞，但是会在编译结束后报错 new webpack.NoErrorsPlugin(), // https://github.com/ampedandwired/html-webpack-plugin // 将 index.html 作为入口，注入 html 代码后生成 index.html文件 new HtmlWebpackPlugin({ filename: &apos;index.html&apos;, template: &apos;index.html&apos;, inject: true }) ] }) webpack.base.conf.js我们看到在 webpack.dev.conf.js 中又引入了 webpack.base.conf.js // 使用 NodeJS 自带的文件路径插件 var path = require(&apos;path&apos;) // 引入 config/index.js var config = require(&apos;../config&apos;) // 引入一些小工具 var utils = require(&apos;./utils&apos;) // 拼接我们的工作区路径为一个绝对路径 var projectRoot = path.resolve(__dirname, &apos;../&apos;) // 将 NodeJS 环境作为我们的编译环境 var env = process.env.NODE_ENV // check env &amp; config/index.js to decide weither to enable CSS Sourcemaps for the // various preprocessor loaders added to vue-loader at the end of this file // 是否在 dev 环境下开启 cssSourceMap ，在 config/index.js 中可配置 var cssSourceMapDev = (env === &apos;development&apos; &amp;&amp; config.dev.cssSourceMap) // 是否在 production 环境下开启 cssSourceMap ，在 config/index.js 中可配置 var cssSourceMapProd = (env === &apos;production&apos; &amp;&amp; config.build.productionSourceMap) // 最终是否使用 cssSourceMap var useCssSourceMap = cssSourceMapDev || cssSourceMapProd module.exports = { entry: { // 编译文件入口 app: &apos;./src/main.js&apos; }, output: { // 编译输出的根路径 path: config.build.assetsRoot, // 正式发布环境下编译输出的发布路径 publicPath: process.env.NODE_ENV === &apos;production&apos; ? config.build.assetsPublicPath : config.dev.assetsPublicPath, // 编译输出的文件名 filename: &apos;[name].js&apos; }, resolve: { // 自动补全的扩展名 extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.vue&apos;], // 不进行自动补全或处理的文件或者文件夹 fallback: [path.join(__dirname, &apos;../node_modules&apos;)], alias: { // 默认路径代理，例如 import Vue from &apos;vue&apos;，会自动到 &apos;vue/dist/vue.common.js&apos;中寻找 &apos;vue&apos;: &apos;vue/dist/vue.common.js&apos;, &apos;src&apos;: path.resolve(__dirname, &apos;../src&apos;), &apos;assets&apos;: path.resolve(__dirname, &apos;../src/assets&apos;), &apos;components&apos;: path.resolve(__dirname, &apos;../src/components&apos;) } }, resolveLoader: { fallback: [path.join(__dirname, &apos;../node_modules&apos;)] }, module: { preLoaders: [ // 预处理的文件及使用的 loader { test: /\\.vue$/, loader: &apos;eslint&apos;, include: projectRoot, exclude: /node_modules/ }, { test: /\\.js$/, loader: &apos;eslint&apos;, include: projectRoot, exclude: /node_modules/ } ], loaders: [ // 需要处理的文件及使用的 loader { test: /\\.vue$/, loader: &apos;vue&apos; }, { test: /\\.js$/, loader: &apos;babel&apos;, include: projectRoot, exclude: /node_modules/ }, { test: /\\.json$/, loader: &apos;json&apos; }, { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: &apos;url&apos;, query: { limit: 10000, name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;) } }, { test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: &apos;url&apos;, query: { limit: 10000, name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;) } } ] }, eslint: { // eslint 代码检查配置工具 formatter: require(&apos;eslint-friendly-formatter&apos;) }, vue: { // .vue 文件配置 loader 及工具 (autoprefixer) loaders: utils.cssLoaders({ sourceMap: useCssSourceMap }), postcss: [ require(&apos;autoprefixer&apos;)({ browsers: [&apos;last 2 versions&apos;] }) ] } } config/index.js终于分析完了 webpack.base.conf.js，来让我们看一下 config/index.js index.js 中有 dev 和 production 两种环境的配置 // see http://vuejs-templates.github.io/webpack for documentation. // 不再重复介绍了 ... var path = require(&apos;path&apos;) module.exports = { // production 环境 build: { // 使用 config/prod.env.js 中定义的编译环境 env: require(&apos;./prod.env&apos;), index: path.resolve(__dirname, &apos;../dist/index.html&apos;), // 编译输入的 index.html 文件 // 编译输出的静态资源根路径 assetsRoot: path.resolve(__dirname, &apos;../dist&apos;), // 编译输出的二级目录 assetsSubDirectory: &apos;static&apos;, // 编译发布上线路径的根目录，可配置为资源服务器域名或 CDN 域名 assetsPublicPath: &apos;/&apos;, // 是否开启 cssSourceMap productionSourceMap: true, // Gzip off by default as many popular static hosts such as // Surge or Netlify already gzip all static assets for you. // Before setting to `true`, make sure to: // npm install --save-dev compression-webpack-plugin // 是否开启 gzip productionGzip: false, // 需要使用 gzip 压缩的文件扩展名 productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;] }, // dev 环境 dev: { // 使用 config/dev.env.js 中定义的编译环境 env: require(&apos;./dev.env&apos;), // 运行测试页面的端口 port: 8080, // 编译输出的二级目录 assetsSubDirectory: &apos;static&apos;, // 编译发布上线路径的根目录，可配置为资源服务器域名或 CDN 域名 assetsPublicPath: &apos;/&apos;, // 需要 proxyTable 代理的接口（可跨域） proxyTable: {}, // CSS Sourcemaps off by default because relative paths are &quot;buggy&quot; // with this option, according to the CSS-Loader README // (https://github.com/webpack/css-loader#sourcemaps) // In our experience, they generally work as expected, // just be aware of this issue when enabling this option. // 是否开启 cssSourceMap cssSourceMap: false } } 至此，我们的 npm run dev 命令就讲解完毕， 下面让我们来看一看执行 npm run build 命令时发生了什么 build.js// https://github.com/shelljs/shelljs // 检查 Node 和 npm 版本 require(&apos;./check-versions&apos;)() // 使用了 shelljs 插件，可以让我们在 node 环境的 js 中使用 shell require(&apos;shelljs/global&apos;) env.NODE_ENV = &apos;production&apos; // 不再赘述 var path = require(&apos;path&apos;) // 加载 config.js var config = require(&apos;../config&apos;) // 一个很好看的 loading 插件 var ora = require(&apos;ora&apos;) // 加载 webpack var webpack = require(&apos;webpack&apos;) // 加载 webpack.prod.conf var webpackConfig = require(&apos;./webpack.prod.conf&apos;) // 输出提示信息 ～ 提示用户请在 http 服务下查看本页面，否则为空白页 console.log( &apos; Tip:\\n&apos; + &apos; Built files are meant to be served over an HTTP server.\\n&apos; + &apos; Opening index.html over file:// won\\&apos;t work.\\n&apos; ) // 使用 ora 打印出 loading + log var spinner = ora(&apos;building for production...&apos;) // 开始 loading 动画 spinner.start() // 拼接编译输出文件路径 var assetsPath = path.join(config.build.assetsRoot, config.build.assetsSubDirectory) // 删除这个文件夹 （递归删除） rm(&apos;-rf&apos;, assetsPath) // 创建此文件夹 mkdir(&apos;-p&apos;, assetsPath) // 复制 static 文件夹到我们的编译输出目录 cp(&apos;-R&apos;, &apos;static/*&apos;, assetsPath) // 开始 webpack 的编译 webpack(webpackConfig, function (err, stats) { // 编译成功的回调函数 spinner.stop() if (err) throw err process.stdout.write(stats.toString({ colors: true, modules: false, children: false, chunks: false, chunkModules: false }) + &apos;\\n&apos;) }) webpack.prod.conf.js// 不再赘述 var path = require(&apos;path&apos;) // 加载 confi.index.js var config = require(&apos;../config&apos;) // 使用一些小工具 var utils = require(&apos;./utils&apos;) // 加载 webpack var webpack = require(&apos;webpack&apos;) // 加载 webpack 配置合并工具 var merge = require(&apos;webpack-merge&apos;) // 加载 webpack.base.conf.js var baseWebpackConfig = require(&apos;./webpack.base.conf&apos;) // 一个 webpack 扩展，可以提取一些代码并且将它们和文件分离开 // 如果我们想将 webpack 打包成一个文件 css js 分离开，那我们需要这个插件 var ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;) // 一个可以插入 html 并且创建新的 .html 文件的插件 var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) var env = config.build.env // 合并 webpack.base.conf.js var webpackConfig = merge(baseWebpackConfig, { module: { // 使用的 loader loaders: utils.styleLoaders({ sourceMap: config.build.productionSourceMap, extract: true }) }, // 是否使用 #source-map 开发工具，更多信息可以查看 DDFE 往期文章 devtool: config.build.productionSourceMap ? &apos;#source-map&apos; : false, output: { // 编译输出目录 path: config.build.assetsRoot, // 编译输出文件名 // 我们可以在 hash 后加 :6 决定使用几位 hash 值 filename: utils.assetsPath(&apos;js/[name].[chunkhash].js&apos;), // 没有指定输出名的文件输出的文件名 chunkFilename: utils.assetsPath(&apos;js/[id].[chunkhash].js&apos;) }, vue: { // 编译 .vue 文件时使用的 loader loaders: utils.cssLoaders({ sourceMap: config.build.productionSourceMap, extract: true }) }, plugins: [ // 使用的插件 // http://vuejs.github.io/vue-loader/en/workflow/production.html // definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串 new webpack.DefinePlugin({ &apos;process.env&apos;: env }), // 压缩 js (同样可以压缩 css) new webpack.optimize.UglifyJsPlugin({ compress: { warnings: false } }), new webpack.optimize.OccurrenceOrderPlugin(), // extract css into its own file // 将 css 文件分离出来 new ExtractTextPlugin(utils.assetsPath(&apos;css/[name].[contenthash].css&apos;)), // generate dist index.html with correct asset hash for caching. // you can customize output by editing /index.html // see https://github.com/ampedandwired/html-webpack-plugin // 输入输出的 .html 文件 new HtmlWebpackPlugin({ filename: config.build.index, template: &apos;index.html&apos;, // 是否注入 html inject: true, // 压缩的方式 minify: { removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true // more options: // https://github.com/kangax/html-minifier#options-quick-reference }, // necessary to consistently work with multiple chunks via CommonsChunkPlugin chunksSortMode: &apos;dependency&apos; }), // split vendor js into its own file // 没有指定输出文件名的文件输出的静态文件名 new webpack.optimize.CommonsChunkPlugin({ name: &apos;vendor&apos;, minChunks: function (module, count) { // any required modules inside node_modules are extracted to vendor return ( module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, &apos;../node_modules&apos;) ) === 0 ) } }), // extract webpack runtime and module manifest to its own file in order to // prevent vendor hash from being updated whenever app bundle is updated // 没有指定输出文件名的文件输出的静态文件名 new webpack.optimize.CommonsChunkPlugin({ name: &apos;manifest&apos;, chunks: [&apos;vendor&apos;] }) ] }) // 开启 gzip 的情况下使用下方的配置 if (config.build.productionGzip) { // 加载 compression-webpack-plugin 插件 var CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;) // 向webpackconfig.plugins中加入下方的插件 var reProductionGzipExtensions = &apos;\\\\.(&apos; + config.build.productionGzipExtensions.join(&apos;|&apos;) + &apos;$)&apos; webpackConfig.plugins.push( // 使用 compression-webpack-plugin 插件进行压缩 new CompressionWebpackPlugin({ asset: &apos;[path].gz[query]&apos;, algorithm: &apos;gzip&apos;, test: new RegExp(reProductionGzipExtensions), // 注：此处因有代码格式化的bug，与源码有差异 threshold: 10240, minRatio: 0.8 }) ) } module.exports = webpackConfig","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"vue-cli","slug":"vue-cli","permalink":"http://yoursite.com/tags/vue-cli/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"webpack总结三","date":"2017-10-07T21:05:18.000Z","path":"2017/10/07/webpack总结三/","text":"插件webpack有很多内置插件,也有第三方插件,用来拓展webpack相关功能如果是第三方插件,需要先安装 HtmlWebpackPlugin自动生成html插件,自动在dist目录下自动生成一个index.html //webpack.config.js var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); module.exports={ entry:&apos;./index.js&apos;, output:{ path:__dirname+&apos;/dist&apos;, filename:&apos;bundle.js&apos; } plugins:[ new HtmlWebpackPlugin() ] } 更多的配置 plugins: [ new HtmlWebpackPlugin({ title: &apos;My App&apos;, filename: &apos;admin.html&apos;, template:&apos;header.html&apos;, inject: &apos;body&apos;, favicon:&apos;./images/favico.ico&apos;, minify:true, hash:true, cache:false, showErrors:false, &quot;chunks&quot;: { &quot;head&quot;: { &quot;entry&quot;: &quot;assets/head_bundle.js&quot;, &quot;css&quot;: [ &quot;main.css&quot; ] }, xhtml:false }) ] extract-text-webpack-plugin提取样式插件 var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;); new ExtractTextPlugin(&quot;[name].[hash].css&quot;) 优化插件需要在生产打包时进行额外的处理,比如压缩js代码.就要用到内置插件UgilifyJsPugin plugins:[ new webpack.optimize.UglifJsPlugin() ] 在生产打包会有更多处理,在vue-cli中有以下配置 new webpack.optimize.CommonsChunkPlugin({ name: &apos;vendor&apos;, minChunks: function (module, count) { // any required modules inside node_modules are extracted to vendor return ( module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, &apos;../node_modules&apos;) ) === 0 ) } }), // extract webpack runtime and module manifest to its own file in order to // prevent vendor hash from being updated whenever app bundle is updated new webpack.optimize.CommonsChunkPlugin({ name: &apos;manifest&apos;, chunks: [&apos;vendor&apos;] }), 总之,webpack配置还挺复杂,值得弄明白,听说以前还有专门的webpack岗位,下面还会就vue-cli这种专业的配置总结一下.","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack总结二","date":"2017-10-07T16:41:33.000Z","path":"2017/10/07/webpack总结二/","text":"csswebpack提供了两个工具处理样式表 –&gt; css-loader 和 style-loadercss-loader 可以使用类似@import或url(…)的方法实现require的功能style-loader将所有计算后的样式加入到页面中两者缺一不可(多个加载器中间用!分割,从右向左执行,也可写成数组形式) {test:/\\.css$/, loader:&apos;style!css&apos; //也可以写成 loader:[&apos;style&apos;,&apos;css&apos;] } css预处理比如 less-loader/sass-loader/sylus-loader以less为例 先npm i less-loader –dev { test: /\\.(less|css)$/, use:[ &apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;], }, postcss有好几个功能,这里只介绍为css代码添加前缀来适应不同的浏览器 先安装postcss-loader 和 依赖的插件autoprefixer 在配置中(webpack2中配置方式好像变化了,注意) module: { rules: [ {test: /\\.css$/, loader: &apos;style!css!postcss&apos;} ] }, postcss: [require(&apos;autoprefixer&apos;)] //声明依赖的插件 entry(入口)可以是字符串,数组,对象 只有一个入口 添加彼此互不依赖文件用数组,如[‘./xx/a.js’, ‘./xx/b.js’],最后打包时会在bundle.js后面添加b.js 如果是多页面应用(非spa),则为每个页面生成一个bundle文件, entry:{ &apos;indexEntry&apos; : &apos;./src/index,js&apos;, &apos;pageAEntry&apos; : &apos;./src/pageA.js&apos; }, output:{ path:&apos;./dist&apos;, filename:&apos;[name].js&apos; //name取自entry的属性键名 } output(输出)两个选项 output: { path: &apos;./dist&apos;, //webpack打包后文件存放位置 publicPath: &apos;http://cdn...&apos; //生产环境下 静态资源访问地址,比如要把打包后的文件放到cnd上,就可以配置这个选项 }","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack总结(一)","date":"2017-10-07T12:24:53.000Z","path":"2017/10/07/webpack总结-一/","text":"前言作为一个前端开发者,现在已经不可避免的要和webpack打交道了,尤其使用vuejs以后,项目上不可避免要使用集成webpack的vue-cli. vue-cli基本上已经配置好了相关的webpack配置,基本上就可以开发了,不用开发人员再配置webpack,省时省力. 但是webpack还是要弄清除基本的配置,尤其在面试的时候不可避免被问到,我在网上看到好多讲解的文章,受益匪浅,但是总是看时明白,过两天就忘记了,望而复始,所以想总结一下,以便能有个地方可以随时查阅,下面会引用别人的文章,以及自己的理解,肯定会有错误之处,请多对比. webpack特点是一个模块打包工具,不同于gulp,gulp只是一个构建工具,只执行相应的任务,比如说压缩/合并/检查/自动刷新等等,替代了人工操作,提高了开发人员的工作效率而已,不会对项目结构有所影响. webpack会把js/css/image/html等文件都视作模块,根据模块依赖关系进行静态分析,然后将这些模块按照指定的规则生成对应的静态资源.不仅仅可以执行压缩/合并等任务,还会深度参与项目结构.而且可以根据需求生成多个打包js,可以异步加载,实现按需加载. 两个特点: 一切皆模块 按需加载 webpack基本配置可以子命令行执行 webpack ………来打包 一般专门配置webpack.config.js来方便的只在命令行执行webpack来打包. 实际开发中一般又分成webpack.dev.config.js和webpack.build.config.js,还可能有webpack.test.config.js.具体可以参考vue-cli,后面在具体讲解. const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //installed via npm const webpack = require(&apos;webpack&apos;); //to access built-in plugins const path = require(&apos;path&apos;); const config = { entry: &apos;./path/to/my/entry/file.js&apos;, output: { path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; }, module: { rules: [ {test: /\\.(js|jsx)$/, loader: &apos;babel-loader&apos;} ] }, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin({template: &apos;./src/index.html&apos;}) ] }; module.exports = config; 这是一个简单的示例,还有其他配置选项,下面一个一个来介绍.(因为webpack2配置方面有点改变比如,loader-&gt;rules等等,可能下面的会有所冲突) 生成source Maps(调试用)需要在配置中设置devtool:’source-map’ (总共有七个选项,不同选项,打包速度也快,但也越不利于调试,调试也是各坑,有的选项打不上断点或者断点在下一行) 构建本地服务器只从有了nodejs以后,前端就可以用node在本地起服务,而不用在配置java服务.而且webpack也是基于nodejs的. 1.npm 安装webpack-dev-server,这是一个基于express的webpack服务. 2.在配置中 devServer:{ contentBase:&apos;./dist&apos;, colors:true, historyApiFallback:true, inline:true } loaders 通过不同的loader,对各种文件进行处理 安装 在配置的modules属性下进行配置 module: { rules: [ { test: /\\.(js|vue)$/, loader: &apos;eslint-loader&apos;, enforce: &apos;pre&apos;, include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)], options: { formatter: require(&apos;eslint-friendly-formatter&apos;) } }, { test: /\\.vue$/, loader: &apos;vue-loader&apos;, options: vueLoaderConfig }, { test: /\\.js$/, loader: &apos;babel-loader&apos;, include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)] }, { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: &apos;url-loader&apos;, options: { limit: 10000, name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;) } }, { test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/, loader: &apos;url-loader&apos;, options: { limit: 10000, name: utils.assetsPath(&apos;media/[name].[hash:7].[ext]&apos;) } }, { test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: &apos;url-loader&apos;, options: { limit: 10000, name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;) } } ] } 必选属性: test: 匹配要处理的文件扩展名(正则表达式) loader而: 加载器 可选属性: include: 手动添加必须处理的文件(文件夹) exclude: 手动屏蔽不需要处理的文件(文件夹) query: 提供额外的处置选项,也可以直接写在loader里(webpack2应该是改成options,如上面的配置) {test:/\\.png|jpe?g|ico$/, loader:&apos;url-loader&apos;, exclude:&apos;/node-modles/&apos;,(举例而已,实际没有) query:{ limited:10000, name: &apos;[name].[ext]?[hash]&apos; } } bable将ES6转化为ES5的包,会有好几个包,核心功能在bable-core这个包中用的最多的是解析ES6的babel-prsent-es2015和解析jsx的bable-present-react配置如下: loaders:[{ test:/\\.js$/, exclude:&apos;/node_modules&apos;, laoder:&apos;babel&apos;, query:{ presets:[&apos;es2015&apos;,&apos;react&apos;] } }] bable还有非常的配置选项,实际一般把配置选项放到’bablerc’这个单独的文件中,webpack会自动调用.","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"使用代理解决跨域限制","date":"2017-10-06T21:00:53.000Z","path":"2017/10/06/使用代理解决跨域限制/","text":"问题1 . 在跨域请求(经常是在用到别人的接口时)会遇到一些限制,对方会检查http请求携带的来源,比如检查host,referer等. 代理1 . 我们可以在本地起一个node服务,比如vue开发中的dev-server,使用其发http请求,通过修该请求信息,能够被对方接口通过返回数据,又因为同源策略是浏览器安全的范畴,所以在node上不用考虑跨域问题.2 . 项目中只需发一个ajax请求(因为向本地node服务发,故同源,不用考虑跨域).vue中使用axios作为ajax工具,其既可以在浏览器中使用,也可以在node中使用. import axios from &apos;axios&apos;, let url = &apos;/api/getData&apos;, let data = {....}, axios.get(url, { params: data }).then((res) =&gt; { ........................... }) 3 . 在本地node服务中对请求’/api/getData’做代理,发请求到实际的接口 var axios = require(&apos;axios&apos;) var app = express() var apiRoutes = express.Router() apiRoutes.get(&apos;/getData&apos;, function (req, res) { //实际接口 var url = &apos;https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg&apos; //修改请求头信息 axios.get(url, { headers: { referer: &apos;https://c.y.qq.com/&apos;, host: &apos;c.y.qq.com&apos; }, params: req.query }).then((response) =&gt; { res.json(response.data) }).catch((e) =&gt; { console.log(e) }) }) app.use(&apos;/api&apos;, apiRoutes)","tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"jsonp使用及promise封装","date":"2017-10-05T11:38:12.000Z","path":"2017/10/05/jsonp使用及promise封装/","text":"1 .jsonp简单封装了跨域请求方法jsonp,利用script标签不受同源策略的限制,达到ajax的效果. 2 . jsonp(url, opts, fn) url (String) url to fetch opts (Object), optional param (String) name of the query string parameter to specify the callback (defaults to callback) timeout (Number) how long after a timeout error is emitted. 0 to disable (defaults to 60000) prefix (String) prefix for the global callback functions that handle jsonp responses (defaults to __jp) name (String) name of the global callback functions that handle jsonp responses (defaults to prefix + incremented counter) fn callback The callback is called with err, data parameters. If it times out, the err will be an Error object whose message is Timeout. Returns a function that, when called, will cancel the in-progress jsonp request (fn won&apos;t be called). opts 中里面属性都有默认值,可以不用设置,但是注意param是前后端协议好的请求字段,默认值为callback,后端要根据这个字段拿到函数名,也就是另一个属性name,即jsonp原理中js中已经定义好的函数(jsonp内部会分配给全局对象对应属性,有name则是name值,如果没有则会根据prefix自动分配,并赋值fn). 3.这种用回调函数异步编程的方式可以利用ES6的promise实现同步编程,更加直观. 举例来讲 //构造函数接受两个参数,分别代表已完成/未完成两种状态变化,返回一各实例,可以在其then方法里传入成功时处理函数和失败时处理函数 var promise = new Promise(function(resolve,reject){ 异步操作代码...... resolve(value) reject(error) } promise.then(function(value){......},function(err){....}) 4.利用promise改造jsonp import originJSONP from &apos;jsonp&apos; export default function jsonp(url, data, option) { url += (url.indexOf(&apos;?&apos;) &lt; 0 ? &apos;?&apos; : &apos;&amp;&apos;) + param(data) return new Promise((resolve, reject) =&gt; { originJSONP(url, option, (err, data) =&gt; { if (!err) { resolve(data) } else { reject(err) } }) }) } function param(data) { let url = &apos;&apos; for (var k in data) { let value = data[k] !== undefined ? data[k] : &apos;&apos; url += `&amp;${k}=${encodeURIComponent(value)}` } return url ? url.substring(1) : &apos;&apos; } 5.使用(在vue中使用) import jsonp from &apos;./xxxxx&apos; data(){ return { data:&apos;&apos; } }, methods:{ getData(){ let url=&apos;**********&apos; let data = {xxxxxxx:xxxxx} let option = {xxxxx:xxxxx} jsonp(url,data,option).then((res) =&gt; { if (res.code === 0) { this.data = res.data.list } }) } }","tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"},{"name":"jsonp","slug":"jsonp","permalink":"http://yoursite.com/tags/jsonp/"},{"name":"promise","slug":"promise","permalink":"http://yoursite.com/tags/promise/"},{"name":"异步同步","slug":"异步同步","permalink":"http://yoursite.com/tags/异步同步/"}]},{"title":"swiper-animate 冲突解决","date":"2017-04-23T11:39:44.000Z","path":"2017/04/23/swiper-animal-冲突解决/","text":"冲突 swiper是个使用广泛，兼容性很高的js插件，可以独立使用，也可以跟jQuery配合使用。 swiper-animate是swiper基础上开发的动画插件，可以实现非常酷炫的效果。 这周在写一个页面，里面有轮播图、tab选项卡，用swiper开发非常方便，当然也用到了swiper-animate，但是，两个swiper实例之间的 swiper-animate会互相影响，发生动画效果消失或错乱。 在网上也没找到解决办法，最后只能用笨办法了。 #解决 在swiper-animate.jsh中复制三个函数，并分别改名为原名+me，修改querySelectorAll(“.ani”)为querySelectorAll(“.anime”)。 在html中把第二个用到动画的标签类名由ani改成animate 在js中创建实例时候，调用修改过的函数名。 这样就解决了冲突，只是办法太笨了。","tags":[{"name":"swiper-animal","slug":"swiper-animal","permalink":"http://yoursite.com/tags/swiper-animal/"}]},{"title":"hexo+github+AppVeyor实现不同电脑写博客","date":"2017-04-06T17:32:14.000Z","path":"2017/04/06/hexo-github-AppVeyor实现不同电脑写博客/","text":"hexo + github 部分 以前一直用的像博客园这样专业的博客网站,但是一直想有个个人站点,正好github提供这样的类似功能,并且发现hexo这样的好工具.hexo使用markdown写文章,并且支持github部署.这就很完美了. 如何使用,网上已有好多教程,不再赘言. 美中不足的是:换了电脑或者电脑坏了,源文件丢失,就得重新写,非常的麻烦. 网上也有很多解决方式,我比较喜欢在github备份源文件,并且使用AppVeyor实现自动部署,不用在本地产生文件,也不用即备份又要部署那么繁琐. 我是学习这篇教程做的,Hexo的版本控制与持续集成,以下也是我根据其做的实践. AppVeyor持续集成我是在今年被问到CI,才知道持续集成这个东东的.也没有有机会实践,所以只能跟着教程一步一步操作. 新建两个github仓库,一个是 killerlei.github.io.(以我的为例) ,另一个是便是备份源文件的仓库 hexo-github-source(以我的为例). 注册APPVeyor,支持github登录,然后新建项目,直接选择github里面的源文件仓库hexo-github-source 在该项目的settings中设置Envirommemt 在源文件根目录中添加appveyor.yml配置文件,我的如下 12345678910111213141516171819202122232425clone_depth: 5environment: access_token: secure: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(这里需要自己的)install: - node --version - npm --version - npm install - npm install hexo-cli -gbuild_script: - hexo generateartifacts: - path: public on_success: - git config --global credential.helper store - ps: Add-Content &quot;$env:USERPROFILE\\.git-credentials&quot; &quot;https://$($env:access_token):x-oauth-basic@github.com`n&quot; - git config --global user.email &quot;%GIT_USER_EMAIL%&quot; - git config --global user.name &quot;%GIT_USER_NAME%&quot; - git clone --depth 5 -q --branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\\static-site - cd %TEMP%\\static-site - del * /f /q - for /d %%p IN (*) do rmdir &quot;%%p&quot; /s /q - SETLOCAL EnableDelayedExpansion &amp; robocopy &quot;%APPVEYOR_BUILD_FOLDER%\\public&quot; &quot;%TEMP%\\static-site&quot; /e &amp; IF !ERRORLEVEL! EQU 1 (exit 0) ELSE (IF !ERRORLEVEL! EQU 3 (exit 0) ELSE (exit 1)) - git add -A - if &quot;%APPVEYOR_REPO_BRANCH%&quot;==&quot;master&quot; if not defined APPVEYOR_PULL_REQUEST_NUMBER (git diff --quiet --exit-code --cached || git commit -m &quot;Update Static Site&quot; &amp;&amp; git push origin %TARGET_BRANCH% &amp;&amp; appveyor AddMessage &quot;Static Site Updated&quot;) 第4步需要个人的secure,先到github新建 Personal access tokens,然后到AppVeyor加密AppVeyor加密,然后写到第4步里 现在就可以在本地写文章了,比如 新建一篇文章 hexo new “hexo使用总结”hexo s (在本地浏览器检查正常)git push origin master (推送到源文件备份仓库) 现在AppVeor就开始自动构建. 成功后就会把生成的文件推送到killerlei.github.io.仓库 就可以在killerlei.github.io.访问到新建的文章. 这样是不是很方便,换个电脑直接从源文件仓库clone下来,也不怕丢失.ps:如果使用了hexo的非默认主题,可能会遇到这样的情况(比如我用的yilia主题):向源文件仓库push时,会失败,我在网上查了以下,好像是主题文件含有.git文件,本来受git控制,所以会冲突.需要删除.git. 我弄了好久才糊里糊涂弄好.如需帮助,请看.git解决1和.git解决2 //更新 2017-10-14 使用持续集成,本地开发预览完整,但是线上会有问题,会遇到文章列表没有,提示 模块缺失,要安装 hexo-generator-json-content.这个问题其实是nodejs 版本低,APPVeyor默认的是version4,要设置builde选项中Platform为x86,并在appveyor.yml中设置 1234567891011121314 nodejs_version: &quot;6&quot; access_token: secure: DO1FA80B0MgslEfR6NntOIORHAtFOrzO70MvNfZK3OIHpXrundrrSBSx+nEkgx9minstall: # Get the latest stable version of Node.js or io.js - ps: Install-Product node $env:nodejs_version # install modules - npm install - node --version - npm --version - npm install - npm install hexo-cli -g 这样就ok了,会升级nodejs.","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"AppVeyor","slug":"AppVeyor","permalink":"http://yoursite.com/tags/AppVeyor/"},{"name":"持续集成","slug":"持续集成","permalink":"http://yoursite.com/tags/持续集成/"}]}]